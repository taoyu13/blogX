import{_ as t,o as d,c as e,V as a}from"./chunks/framework.dd578c14.js";const _=JSON.parse('{"title":"正则表达式","description":"","frontmatter":{},"headers":[],"relativePath":"base/tools/reg.md","lastUpdated":null}'),r={name:"base/tools/reg.md"},o=a('<h1 id="正则表达式" tabindex="-1">正则表达式 <a class="header-anchor" href="#正则表达式" aria-label="Permalink to &quot;正则表达式&quot;">​</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>正则表达式在日常开发中的使用频率非常高，熟练掌握正则表达式能够在开发中事半功倍。</p><p>就前端而言，对特殊字符串的处理通常就要用到。而正则表达式规则繁杂生涩，不花点时间系统学习很难熟练掌握。</p><p>以前每次碰到都要去 csdn 查一遍，这次痛定思痛，一定要给它拿下了。</p><h2 id="单个字符" tabindex="-1">单个字符 <a class="header-anchor" href="#单个字符" aria-label="Permalink to &quot;单个字符&quot;">​</a></h2><p>对于单个字符，字符和正则表达式一般是一一对应的关系。例如匹配<code>apple</code>中的&#39;a&#39;字符只需用<code>/a/</code>就行了，简单的数字和字母都是如此。</p><h3 id="转义字符" tabindex="-1">转义字符 <a class="header-anchor" href="#转义字符" aria-label="Permalink to &quot;转义字符&quot;">​</a></h3><p>当单个简单字符无法表达需要的意思时，就要用到转义字符<code>\\</code>，加在其前面，使其意思发生变化。</p><p>若为<code>特殊字符</code>，在其前面加上转义字符<code>\\</code>后，代表字符其本身，失去特殊含义(<code>\\*</code>就是代表*符号)。</p><p>如果不是<code>特殊字符</code>，加上转义字符后就会赋予特殊的含义，下面列举出常用的<code>特殊字符</code>和对应的正则表达式：</p><table><thead><tr><th>特殊字符</th><th>正则表达式</th><th>记忆方式</th></tr></thead><tbody><tr><td>换行符</td><td>\\n</td><td>new line</td></tr><tr><td>换页符</td><td>\\f</td><td>form feed</td></tr><tr><td>回车符</td><td>\\r</td><td>return</td></tr><tr><td>空白符</td><td>\\s</td><td>space</td></tr><tr><td>制表符</td><td>\\t</td><td>tab</td></tr><tr><td>垂直制表符</td><td>\\v</td><td>vertical tab</td></tr></tbody></table><h2 id="多个字符" tabindex="-1">多个字符 <a class="header-anchor" href="#多个字符" aria-label="Permalink to &quot;多个字符&quot;">​</a></h2><p>单个字符的一对一匹配显然是不够的，为了实现一对多的多字符匹配，引入了<code>集合区间</code>和<code>通配符</code>的概念。</p><p>正则表达式中用中括号[]来表示集合的概念，在集合中又有<code>列举</code>和<code>区间</code>两种表达方式。</p><p>当需要匹配的字符不多时，可以直接在集合中列举出来，例如<code>/[abc]/</code>能同时匹配 a、b、c 三个字符。</p><p>当需要匹配很多字符时，用区间符号<code>-</code>，例如<code>/[0-9]/</code>能够匹配所有的数字。</p><p>为了追求更简洁的表达，衍生了一批能够同时匹配多个字符的通配符：</p><table><thead><tr><th>匹配区间</th><th>正则表达式</th><th>记忆方式</th></tr></thead><tbody><tr><td>除换行符外的任意字符</td><td>.</td><td>一点一世界</td></tr><tr><td>单个数字，[0-9]</td><td>\\d</td><td>digit</td></tr><tr><td>除了[0-9]</td><td>\\D</td><td>大写即否定</td></tr><tr><td>包括下划线在内的单个字符，[A-Za-z0-9_]</td><td>\\w</td><td>通吃单个常用字符</td></tr><tr><td>非单字字符</td><td>\\W</td><td>大写即否定</td></tr><tr><td>匹配空白字符,包括空格、制表符、换页符和换行符</td><td>\\s</td><td>space</td></tr><tr><td>匹配非空白字符</td><td>\\S</td><td>大写即否定</td></tr></tbody></table><h2 id="循环与重复" tabindex="-1">循环与重复 <a class="header-anchor" href="#循环与重复" aria-label="Permalink to &quot;循环与重复&quot;">​</a></h2><p>上述一对一和一对多的场景都是针对单个字符结果的，若要匹配多个字符组成的结果，就要用到重复与循环的方法。正则表达式中用若干元字符来表示不同的循环方式：</p><table><thead><tr><th>匹配规则</th><th>元字符</th><th>记忆方式</th></tr></thead><tbody><tr><td>0 次 或 1 次</td><td>?</td><td>有还是没有？</td></tr><tr><td>0 次 或 无数次</td><td>*</td><td>只有零次和无数次</td></tr><tr><td>1 次 或 无数次</td><td>+</td><td>起码还有一次</td></tr><tr><td>特定次数</td><td><code>{x}, {min,max}</code></td><td>括号指定次数</td></tr></tbody></table><h2 id="位置与边界" tabindex="-1">位置与边界 <a class="header-anchor" href="#位置与边界" aria-label="Permalink to &quot;位置与边界&quot;">​</a></h2><p>在长文本字符串的处理中，我们经常要限制匹配的位置与边界，比如在字符串的开头或结尾匹配。</p><h3 id="单词边界" tabindex="-1">单词边界 <a class="header-anchor" href="#单词边界" aria-label="Permalink to &quot;单词边界&quot;">​</a></h3><p>在英语句子中匹配某个单词时，需要用到单词边界通配符<code>\\b</code>，其中<code>b</code>为<code>boundary</code>的首字母，在正则引擎中匹配的是字符(<code>\\w</code>)和非字符(<code>\\W</code>)的中间位置。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Legend never die.  /\\bnever\\b/:匹配never</span></span></code></pre></div><h3 id="字符串边界" tabindex="-1">字符串边界 <a class="header-anchor" href="#字符串边界" aria-label="Permalink to &quot;字符串边界&quot;">​</a></h3><p>元字符<code>^</code>用来匹配字符串的开头。而元字符<code>$</code>用来匹配字符串的末尾。</p><p>在长文本中，如果要排除换行符的干扰，则要开启多行模式，在正则表示式结尾添加<code>m</code>，例如：<code>/^never say never$/m</code>。</p><p>总结如下：</p><table><thead><tr><th>边界标志</th><th>正则表达式</th><th>记忆方式</th></tr></thead><tbody><tr><td>单词边界</td><td>\\b</td><td>boundary</td></tr><tr><td>非单词边界</td><td>\\B</td><td>大写即否定</td></tr><tr><td>字符串开头</td><td>^</td><td>小荷才露尖尖角</td></tr><tr><td>字符串结尾</td><td>$</td><td>万事归于钱</td></tr><tr><td>多行模式</td><td>m</td><td>multiple of lines</td></tr><tr><td>忽略大小写</td><td>i</td><td>ignore case</td></tr><tr><td>全局模式</td><td>g</td><td>global</td></tr></tbody></table><h2 id="应用与方法" tabindex="-1">应用与方法 <a class="header-anchor" href="#应用与方法" aria-label="Permalink to &quot;应用与方法&quot;">​</a></h2>',33),c=[o];function h(l,n,s,i,p,b){return d(),e("div",null,c)}const m=t(r,[["render",h]]);export{_ as __pageData,m as default};
